from matplotlib import projections
import tensorflow as tf
import numpy as np 
import time
import pandas as pd
import utility as ut
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

DTYPE = 'float64'


class Grid:
    """
    A class for collecting grid data for MC simulation

    Attributes:
        dim: dimension of the grid
        mins: array of lower bounds for the grid
        maxs: array of upper bounds for the grid 
        h: array of step sizes in every dimension 
        dV: volume of smallest cube in the grid
    """
    def __init__(self, dim):
        self.dim = dim
        self.mins = np.zeros(dim)
        self.maxs = np.zeros(dim) 
        self.h = np.zeros(dim)
        self.dV = np.prod(self.h)


class MCProb:
    """
    A class for computing Monte Carlo estimate of 2d densities with 
    the SDE of the form dX_t = mu(X_t)dt + sigma x dW_t

    Attributes:
        mu: drift in the the SDE 
        sigma: constant diffusion in the SDE 
        X0: initial ensemble 
        save_folder: folder to save the generated data
    """
    def __init__(self, save_folder, n_subdivs, mu=None, sigma=None, X0=None, tick_size=15, title_size=15, cbar_tick_size=10):
        self.X = X0 
        self.mu = mu 
        self.sigma = sigma
        self.save_folder = save_folder
        self.n_subdivs = n_subdivs
        self.n_particles = len(X0)
        self.dim = X0.shape[-1]
        self.grid = Grid(dim=self.dim)
        self.total_sims = self.n_particles
        self.tick_size = tick_size
        self.cbar_tick_size = cbar_tick_size
        self.title_size = title_size

    @ut.timer
    def propagate(self, n_steps, dt):
        """
        Description: propagates particles according to the SDE and stores the final positions

        Args:
            n_steps: number of steps in Euler-Maruyama
            dt: time-step in Euler-Maruyama
        """
        self.final_time = dt * n_steps
        self.n_steps = n_steps
        start = time.time()
        for step in range(n_steps):
            self.X +=  self.mu(self.X) * dt + self.sigma * np.random.normal(scale=np.sqrt(dt), size=(self.n_particles, self.dim))
            if step%1000 == 0:
                print('step = {}, time taken = {:.4f}'.format(step, time.time() - start), end='\r')
        pd.DataFrame(self.X).to_csv('{}/ensemble.csv'.format(self.save_folder), index=None, header=None)


    def roundup(self, real, n):
        """
        Description: Rounds up a real number to desired number of decimal points

        Args:
            real: a real number to round
            n: required number of decimal points
        """
        real *= 10.**n 
        return np.ceil(real) / (10.**n)
    
    @ut.timer
    def set_grid(self, lims=None):
        """
        Description: Computes shape of the grid generated by the propagation
        """
        pts = np.genfromtxt('{}/ensemble.csv'.format(self.save_folder), delimiter=',')
        if lims is None:
            for d in range(self.dim):
                self.grid.mins[d], self.grid.maxs[d] = self.roundup(min(pts[:, d]), 2), self.roundup(max(pts[:, d]), 2)
            min_max = np.array(list(zip(self.grid.mins, self.grid.maxs)))
        else:
            min_max = np.array(lims).T
            new_pts = []
            for pt in pts:
                a = pt - min_max.T[0]
                b = min_max.T[1] - pt 
                c = a * b
                if c[0] > 0. and c[1] > 0. and c[2] > 0.:
                    new_pts.append(pt) 
            pd.DataFrame(np.array(new_pts)).to_csv('{}/ensemble.csv'.format(self.save_folder), index=None, header=None)
        pd.DataFrame(min_max).to_csv('{}/min_max.csv'.format(self.save_folder), index=None, header=None)


    def get_grid(self):
        """
        Description: Reads pre-computed grid 
        """
        min_max = np.genfromtxt('{}/min_max.csv'.format(self.save_folder), delimiter=',')
        for d in range(self.dim):
            self.grid.mins[d], self.grid.maxs[d] = min_max[d]
        
        self.grid.h = (self.grid.maxs - self.grid.mins) / self.n_subdivs
        self.grid.dV = np.prod(self.grid.h)
        return self.grid


    @ut.timer
    def assign_pts(self):
        """
        Description: Assigns the generated points to the grid boxes
        """
        pts = np.genfromtxt('{}/ensemble.csv'.format(self.save_folder), delimiter=',')
        self.get_grid()
        coords = ((pts - self.grid.mins) / self.grid.h).astype(int)
        pd.DataFrame(coords).to_csv('{}/coordinates.csv'.format(self.save_folder), index=None, header=None)

    
    @ut.timer
    def compute_pd(self):
        """
        Description: Computes probability in each box in the grid
        """
        coords = np.genfromtxt('{}/coordinates.csv'.format(self.save_folder), delimiter=',')
        boxes, counts = np.unique(coords, return_counts=True, axis=0)
        
        pd.DataFrame(boxes).to_csv('{}/boxes.csv'.format(self.save_folder), index=None, header=None)
        pd.DataFrame(counts).to_csv('{}/counts.csv'.format(self.save_folder), index=None, header=None)

        self.get_grid()
        centers = self.grid.mins + boxes * self.grid.h + self.grid.h / 2.
        probs = counts / (self.total_sims * self.grid.dV)
        idx = np.argsort(probs)

        pd.DataFrame(centers[idx][::-1]).to_csv('{}/centers.csv'.format(self.save_folder), index=None, header=None)
        pd.DataFrame(probs[idx][::-1]).to_csv('{}/center_probs.csv'.format(self.save_folder), index=None, header=None)


    @ut.timer
    def compute_p2(self, i, j, save=True):
        """
        Description: Computes probability in each box in a two-dimensional grid

        Args:
            i: index specifying the first dimension
            j: index specifying the second dimension
        """
        coords = np.genfromtxt('{}/coordinates.csv'.format(self.save_folder), delimiter=',')
        boxes, counts = np.unique(coords[:, [i, j]], return_counts=True, axis=0)
        pd.DataFrame(boxes).to_csv('{}/boxes_{}_{}.csv'.format(self.save_folder, i, j), index=None, header=None)
        pd.DataFrame(counts).to_csv('{}/counts_{}_{}.csv'.format(self.save_folder, i, j), index=None, header=None)

        self.get_grid()
        x = np.linspace(self.grid.mins[i], self.grid.maxs[i], num=self.n_subdivs+1)[1:]
        y = np.linspace(self.grid.mins[j], self.grid.maxs[j], num=self.n_subdivs+1)[1:]
        prob = np.zeros((self.n_subdivs, self.n_subdivs))
        
        for k, b in enumerate(boxes):
            prob[int(b[0]), int(b[1])] = counts[k] 

        prob /= (np.sum(prob) * self.grid.h[i] * self.grid.h[j])
        if not save:
            return prob
        x, y = np.meshgrid(x, y)
        
        fig = plt.figure(figsize=(8, 8))
        ax = fig.add_subplot(111)
        im = ax.pcolormesh(x, y, prob, cmap='inferno_r', shading='auto')
        cbar = fig.colorbar(im)
        cbar.ax.tick_params(labelsize=self.cbar_tick_size)
        ax.set_xlabel(r'$x_{}$'.format(i))
        ax.set_ylabel(r'$x_{}$'.format(j))
        def get_char(c):
            if c == 0:
                return 'x'
            elif c == 1:
                return 'y'
            elif c == 2:
                return 'z'

        ax.set_title(r'MC estimate of $p({}, {})$ at time = {:.4f}'.format(get_char(i), get_char(j), self.final_time), fontsize=self.title_size)
        ax.tick_params(axis='both', which='major', labelsize=self.tick_size)
        ax.tick_params(axis='both', which='minor', labelsize=self.tick_size)
        plt.tight_layout()
        plt.savefig('{}/p_{}_{}_mc_steps_{}.png'.format(self.save_folder, i, j, self.n_steps))
        plt.close(fig)
        


    @ut.timer
    def compute_p1(self, i):
        """
        Description: Computes probability in each interval in a one-dimensional grid

        Args:
            i: index specifying the dimension
        """
        coords = np.genfromtxt('{}/coordinates.csv'.format(self.save_folder), delimiter=',')
        boxes, counts = np.unique(coords[:, i], return_counts=True, axis=0)
        pd.DataFrame(boxes).to_csv('{}/boxes_{}.csv'.format(self.save_folder, i), index=None, header=None)
        pd.DataFrame(counts).to_csv('{}/counts_{}.csv'.format(self.save_folder, i), index=None, header=None)

        self.get_grid()
        x = np.linspace(self.grid.mins[i], self.grid.maxs[i], num=self.n_subdivs+1)[1:]
        prob = np.zeros(self.n_subdivs)
        for k, b in enumerate(boxes):
            prob[int(b)] = counts[k]

        prob /= np.sum(prob) * self.grid.h[i]
        fig = plt.figure(figsize=(8, 8))
        ax = fig.add_subplot(111)
        ax.plot(x, prob)
        ax.set_xlabel(r'$x_{}$'.format(i))
        ax.set_ylabel(r'$p(x_{})$'.format(i))
        ax.set_title(r'MC estimate of $p(x_{})$ at time = {:.4f}'.format(i, self.final_time))
        plt.tight_layout()
        plt.savefig('{}/p_{}_mc_steps_{}.png'.format(self.save_folder, i, self.n_steps))
        plt.close(fig) 
    

    @ut.timer
    def ready(self, n_steps, dt, lims=None):
        self.propagate(n_steps, dt)
        self.set_grid(lims)
        self.assign_pts()

    @ut.timer
    def compute_all(self, n_steps, dt, lims=None):
        """
        Description: Computes all d, 2 and 1 dimensional densities

        Args:
            n_steps: number of steps in Euler-Maruyama
            dt: time-step in Euler-Maruyama
        """
        self.ready(n_steps, dt, lims=None)
        self.compute_pd()
        for i in range(self.dim):
            self.compute_p1(i)
            for j in range(i+1, self.dim):
                self.compute_p2(i, j)



    @ut.timer
    def get_slice_pts(self, dims=[0, 1], levels={2: 0.}, eps=0.1):
        pts = np.genfromtxt('{}/ensemble.csv'.format(self.save_folder), delimiter=',')
        for i in levels:
            idx = np.where(pts[:, i] < levels[i] + eps)[0]
            pts = pts[idx, :]
            idx = np.where(pts[:, i] > levels[i] - eps)[0]
            pts = pts[idx, :]
        return pts 

    @ut.timer
    def slice2D(self, dims=[0, 1], levels={2: 0.}, eps=0.1):
        """
        Description: Computes probability on a 2D slice

        Args:
            dims: indices specifying the 2D slice
            levels: values of rest of the dimensions 
            eps: leeway in the rest of the dimensions
        """
        pts = self.get_slice_pts(dims, levels, eps)
        self.get_grid()
        i, j = sorted(dims)
        x = np.linspace(self.grid.mins[i], self.grid.maxs[i], num=self.n_subdivs+1)
        y = np.linspace(self.grid.mins[j], self.grid.maxs[j], num=self.n_subdivs+1)
        prob = np.zeros((self.n_subdivs, self.n_subdivs))
        coords = ((pts - self.grid.mins) / self.grid.h).astype('float32')
        boxes, counts = np.unique(coords[:, [i, j]], return_counts=True, axis=0)
        

        for k, b in enumerate(boxes):
            prob[int(b[0]), int(b[1])] = counts[k] 

        prob /= np.sum(prob)
        x, y = np.meshgrid(x, y)
        fig = plt.figure(figsize=(8, 8))
        ax = fig.add_subplot(111)
        im = ax.pcolormesh(x, y, prob, cmap='inferno_r', shading='auto')
        fig.colorbar(im)
        ax.set_xlabel(r'$x_{}$'.format(i))
        ax.set_ylabel(r'$x_{}$'.format(j))
        ax.set_title(r'MC estimate of $p(x_{}, x_{})$ at time = {:.4f}'.format(i, j, self.final_time))
        plt.tight_layout()
        plt.savefig('{}/p_slice_{}_{}_mc_steps_{}.png'.format(self.save_folder, i, j, self.n_steps))
        plt.close(fig)

    def slice_all(self, levels={0: 0., 1: 0., 2: 0.}, eps=0.1):
        for i in range(3):
            dims =  [(i+1)%3, (i+2)%3]
            self.slice2D(dims=dims, levels={i: levels[i]}, eps=eps)
    






class FKSim3_2:
    """
    Description: Feynman-Kac simulation for a 2D grid taking integration 
    in the other dimension into consideration
    """
    def __init__(self, save_folder, n_subdivs, n_int_subdivs, mu, sigma, n_theta, grid,\
                h0, dtype='float32') -> None:
        self.grid = grid 
        self.mu = mu 
        self.sigma = sigma
        self.net = n_theta
        self.n_theta = lambda X: n_theta(*tf.split(X, 3, axis=-1)).numpy()
        self.n_subdivs = n_subdivs
        self.h0 = h0
        self.dtype = dtype
        self.save_folder = save_folder
        self.dim = 3
        self.n_int_subdivs = n_int_subdivs

    def sol(self, X):
        l = len(X)
        m = int(1e5)
        M = int(np.ceil(l / m))
        data = []
        for i in range(M):
            if i < M-1:
                x = X[i*m: (i+1)*m]
            else:
                x = X[i*m:] 
            data.append(np.exp(self.n_theta(x)))
            
        return np.concatenate(data, axis=0)

    @tf.function
    def h_mu(self, X):
        l = len(X)
        m = int(1e5)
        M = int(np.ceil(l / m))
        data = []
        for i in range(M):
            if i < M-1:
                X_ = X[i*m: (i+1)*m]
            else:
                X_ = X[i*m:]
            x, y, z = tf.split(X_, 3, axis=-1)
            with tf.GradientTape() as tape:
                tape.watch([x, y, z])
                n_ = self.net(x, y, z) 
            grad_n = tf.concat(tape.gradient(n_, [x, y, z]), axis=-1).numpy()
            data.append(self.sigma**2*grad_n - self.mu(X_))
        return data

        

    @ut.timer
    def make_plot(self, n_steps, dt, n_repeats, i, j, k):
        """
        Description: propagates particles according to the SDE and stores the final positions

        Args:
            n_steps: number of steps in Euler-Maruyama
            dt: time-step in Euler-Maruyama
            n_repeats: number of simulations per grid point
            i: x dimension
            j: y dimension 
            k: dimension to be integrated out 
        """
        x = np.linspace(self.grid.mins[i], self.grid.maxs[i], num=self.n_subdivs+1).astype(self.dtype)[1:]
        y = np.linspace(self.grid.mins[j], self.grid.maxs[j], num=self.n_subdivs+1).astype(self.dtype)[1:]
        z = np.linspace(self.grid.mins[k], self.grid.maxs[k], num=self.n_int_subdivs+1).astype(self.dtype).reshape(-1, 1)
        ones = tf.ones_like(z)
        prob = np.zeros((self.n_subdivs, self.n_subdivs))

        self.n_steps = n_steps
        self.final_time = dt * n_steps
        weights = np.ones_like(z)
        # for iw, w in enumerate(weights):
        #     if iw % 2 == 0 and iw > 0:
        #         weights[iw][0] = 2.
        #     else:
        #         weights[iw][0] = 4.
        weights[0][0] = 0.5
        weights[-1][0] = 0.5

        h = (self.grid.maxs[k] - self.grid.mins[k]) / self.n_int_subdivs

        start = time.time()
        for m in range(self.n_subdivs):
            for n in range(self.n_subdivs):
                X0 = tf.concat([e for _, e in sorted(zip([i, j, k], [x[m]*ones, y[n]*ones, z]))], axis=-1).numpy()
                p_inf = self.sol(X0)
                X = np.repeat(X0, repeats=n_repeats, axis=0)
                for step in range(n_steps):
                    X +=  self.h_mu(X) * dt + self.sigma * np.random.normal(scale=np.sqrt(dt), size=X.shape)
                    if step%10 == 0:
                        print('grid_index = {}, step = {}, time taken = {:.4f}'.format((m, n), step, time.time() - start), end='\r')
                h0 = tf.reduce_mean(self.h0(X).reshape((-1, n_repeats)), axis=-1, keepdims=True).numpy()
                prob[m][n] = np.sum(h0 * p_inf * weights) * h 
        
        return prob


        
        
    
    

    



















class Evolution:
    """
    Class for visualizing evolution of an SDE
    """

    def __init__(self, save_folder, mu, sigma) -> None:
        self.mu = mu 
        self.sigma = sigma
        self.save_folder = save_folder

    @ut.timer
    def propagate(self, n_steps, dt, X0):
        self.dt = dt
        self.dim = X0.shape[-1]
        self.n_particles = X0.shape[0]
        self.X = np.zeros((n_steps + 1, self.n_particles, self.dim)).astype(DTYPE)
        self.X[0, :, :] = X0
        dW = np.random.normal(scale=np.sqrt(dt), size=(n_steps, self.n_particles, self.dim)).astype(DTYPE)
        start = time.time()
        for step in range(n_steps):
            self.X[step+1, :, :] = self.X[step, :, :] + self.mu(self.X[step, :, :]) * dt + self.sigma * dW[step, :, :]
            if step%1000 == 0:
                print('step = {}, time taken = {:.4f}'.format(step, time.time() - start), end='\r')
        np.save('{}/evolution.npy'.format(self.save_folder), self.X)


    def final_state(self, idx=[0, 1, 2]):
        """
        Description:
            Animates evolution of an ensemble
        
        Args:
            idx: dimensions to plot
        """
        fig = plt.figure(figsize=(8, 8))
        if len(idx) > 2:
            ax = fig.add_subplot(111, projection='3d')
            p, q, r = idx[:3]
            ax.scatter(self.X[-1, :, p], self.X[-1, :, q], self.X[-1, :, r])
            ax.set_xlabel(r'$x_{}$'.format(p))
            ax.set_ylabel(r'$x_{}$'.format(q))
            ax.set_zlabel(r'$x_{}$'.format(r))
        else:
            ax = fig.add_subplot(111)
            p, q = idx[:2]
            ax.scatter(self.X[-1, :, p], self.X[-1, :, q])
            ax.set_xlabel(r'$x_{}$'.format(p))
            ax.set_ylabel(r'$x_{}$'.format(q))
        
        ax.set_title('time = {:.3f}'.format((len(self.X) - 1) * self.dt))
        plt.savefig(self.save_folder + '/final_state.png')
        

    @ut.timer
    def animate(self, idx=[0, 1, 2], n_frames=100, max_pts=500):
        """
        Description:
            Animates evolution of an ensemble
        
        Args:
            idx: dimensions to plot
            n_frames: number of frames to plot
        """
        fig = plt.figure(figsize=(8, 8))
        if len(idx) > 2:
            ax = fig.add_subplot(111, projection='3d')
            p, q, r = idx[:3]
        else:
            ax = fig.add_subplot(111)
            p, q = idx[:2]

        n_pts = min(self.X.shape[1], max_pts)
        def animator(j):
            ax.clear()
            if len(idx) > 2:
                ax.scatter(self.X[j, :n_pts, p], self.X[j, :n_pts, q], self.X[j, :n_pts, r])
            else:
                ax.scatter(self.X[j, :n_pts, p], self.X[j, :n_pts, q])
            ax.set_title('time = {:.3f}'.format(j * self.dt))

        a = int(self.X.shape[0] / n_frames)
        frames = [f for f in range(self.X.shape[0]) if f%a == 0]
        animation = FuncAnimation(fig=fig, func=animator, frames = frames, interval=50, repeat=False)
        animation.save(self.save_folder + '/evolution.mp4', writer='ffmpeg')

    
    
    def exit_prob(self, domain):
        # check if pints are in the domain
        io = tf.greater((self.X - domain[0]) * (domain[1] - self.X), 0.)
        io = tf.math.reduce_all(io, axis=-1)
        # count points in the domain
        io = np.cumprod(io, axis=0)
        io = np.sum(io, axis=-1) / self.X.shape[1]
     

        fig = plt.figure(figsize=(8, 8))
        ax = fig.add_subplot(111)
        t = [e*self.dt for e in range(len(io))]
        ax.plot(t, 1.0 - io)
        ax.set_ylabel('exit probability')
        ax.set_xlabel('time')
        plt.savefig(self.save_folder + '/exit_prob.png')
        

